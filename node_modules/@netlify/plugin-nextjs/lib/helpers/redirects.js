"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateRedirects = exports.generateStaticRedirects = void 0;
const fs_extra_1 = require("fs-extra");
const globby_1 = __importDefault(require("globby"));
const pathe_1 = require("pathe");
const constants_1 = require("../constants");
const utils_1 = require("./utils");
const generateLocaleRedirects = ({ i18n, basePath, trailingSlash, }) => {
    const redirects = [];
    // If the cookie is set, we need to redirect at the origin
    redirects.push({
        from: `${basePath}/`,
        to: constants_1.HANDLER_FUNCTION_PATH,
        status: 200,
        force: true,
        conditions: {
            Cookie: ['NEXT_LOCALE'],
        },
    });
    i18n.locales.forEach((locale) => {
        if (locale === i18n.defaultLocale) {
            return;
        }
        redirects.push({
            from: `${basePath}/`,
            to: `${basePath}/${locale}${trailingSlash ? '/' : ''}`,
            status: 301,
            conditions: {
                Language: [locale],
            },
            force: true,
        });
    });
    return redirects;
};
const generateStaticRedirects = ({ netlifyConfig, nextConfig: { i18n, basePath }, }) => {
    // Static files are in `static`
    netlifyConfig.redirects.push({ from: `${basePath}/_next/static/*`, to: `/static/:splat`, status: 200 });
    if (i18n) {
        netlifyConfig.redirects.push({ from: `${basePath}/:locale/_next/static/*`, to: `/static/:splat`, status: 200 });
    }
};
exports.generateStaticRedirects = generateStaticRedirects;
const generateRedirects = async ({ netlifyConfig, nextConfig: { i18n, basePath, trailingSlash, appDir }, }) => {
    const { dynamicRoutes, routes: staticRoutes } = await fs_extra_1.readJSON(pathe_1.join(netlifyConfig.build.publish, 'prerender-manifest.json'));
    netlifyConfig.redirects.push(...constants_1.HIDDEN_PATHS.map((path) => ({
        from: `${basePath}${path}`,
        to: '/404.html',
        status: 404,
        force: true,
    })));
    if (i18n && i18n.localeDetection !== false) {
        netlifyConfig.redirects.push(...generateLocaleRedirects({ i18n, basePath, trailingSlash }));
    }
    const dataRedirects = [];
    const pageRedirects = [];
    const isrRedirects = [];
    const dynamicRouteEntries = Object.entries(dynamicRoutes);
    const staticRouteEntries = Object.entries(staticRoutes);
    staticRouteEntries.forEach(([route, { dataRoute, initialRevalidateSeconds }]) => {
        // Only look for revalidate as we need to rewrite these to SSR rather than ODB
        if (initialRevalidateSeconds === false) {
            // These can be ignored, as they're static files handled by the CDN
            return;
        }
        if ((i18n === null || i18n === void 0 ? void 0 : i18n.defaultLocale) && route.startsWith(`/${i18n.defaultLocale}/`)) {
            route = route.slice(i18n.defaultLocale.length + 1);
        }
        isrRedirects.push(...utils_1.netlifyRoutesForNextRoute(dataRoute), ...utils_1.netlifyRoutesForNextRoute(route));
    });
    dynamicRouteEntries.forEach(([route, { dataRoute, fallback }]) => {
        // Add redirects if fallback is "null" (aka blocking) or true/a string
        if (fallback === false) {
            return;
        }
        pageRedirects.push(...utils_1.netlifyRoutesForNextRoute(route));
        dataRedirects.push(...utils_1.netlifyRoutesForNextRoute(dataRoute));
    });
    const publicFiles = await globby_1.default('**/*', { cwd: pathe_1.join(appDir, 'public') });
    // This is only used in prod, so dev uses `next dev` directly
    netlifyConfig.redirects.push(
    // API routes always need to be served from the regular function
    {
        from: `${basePath}/api`,
        to: constants_1.HANDLER_FUNCTION_PATH,
        status: 200,
    }, {
        from: `${basePath}/api/*`,
        to: constants_1.HANDLER_FUNCTION_PATH,
        status: 200,
    }, 
    // Preview mode gets forced to the function, to bypass pre-rendered pages, but static files need to be skipped
    ...publicFiles.map((file) => ({
        from: `${basePath}/${file}`,
        // This is a no-op, but we do it to stop it matching the following rule
        to: `${basePath}/${file}`,
        conditions: { Cookie: ['__prerender_bypass', '__next_preview_data'] },
        status: 200,
    })), {
        from: `${basePath}/*`,
        to: constants_1.HANDLER_FUNCTION_PATH,
        status: 200,
        conditions: { Cookie: ['__prerender_bypass', '__next_preview_data'] },
        force: true,
    }, 
    // ISR redirects are handled by the regular function. Forced to avoid pre-rendered pages
    ...isrRedirects.map((redirect) => ({
        from: `${basePath}${redirect}`,
        to: constants_1.ODB_FUNCTION_PATH,
        status: 200,
        force: true,
    })), 
    // These are pages with fallback set, which need an ODB
    // Data redirects go first, to avoid conflict with splat redirects
    ...dataRedirects.map((redirect) => ({
        from: `${basePath}${redirect}`,
        to: constants_1.ODB_FUNCTION_PATH,
        status: 200,
    })), 
    // ...then all the other fallback pages
    ...pageRedirects.map((redirect) => ({
        from: `${basePath}${redirect}`,
        to: constants_1.ODB_FUNCTION_PATH,
        status: 200,
    })), 
    // Everything else is handled by the regular function
    { from: `${basePath}/*`, to: constants_1.HANDLER_FUNCTION_PATH, status: 200 });
};
exports.generateRedirects = generateRedirects;
